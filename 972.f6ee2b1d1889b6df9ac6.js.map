{"version":3,"mappings":"yNAqBIA,EAAkB,CAAEC,wBAAwB,GAqQhD,WAAwBC,EAAOC,GAC3B,YAAgB,IAAZA,IAAsBA,EAAU,IA1BxC,SAAoBD,GAChB,OA5OJ,SAAiBE,EAAKD,GAClB,YAAgB,IAAZA,IAAsBA,EAAUH,GAE7B,IAAIK,IAAW,SAAUC,GAM5B,MAAO,CAAEC,aALSC,QAAWJ,EAAKD,EAAS,CACvCM,KAAMH,EAAWG,KAAKC,KAAKJ,GAC3BK,MAAOL,EAAWK,MAAMD,KAAKJ,GAC7BM,SAAUN,EAAWM,SAASF,KAAKJ,QAqOpCO,CAAQX,EAAO,CAAED,wBAAwB,IAAQa,MAAKC,OAAI,SAAUC,GAAW,OAAOA,EAAQC,QA0B9FC,CAAWhB,GAAOY,MAAKC,OAAI,SAAUI,GACxC,OAAOA,EAAIJ,IAAI,SAAUK,GAAQ,OA/NzC,SAAoBC,EAAUlB,QACV,IAAZA,IAAsBA,EAAU,IAEpC,IAAImB,EAAOD,EAASC,OAGpB,OAAKD,EAASE,UAA4B,iBAATD,GAA8B,OAATA,GAGlDnB,EAAQqB,UACRF,EAAKnB,EAAQqB,SAAWH,EAASI,IAE9BH,EAmNqCI,CAAWN,EAAMjB,mECvRvDwB,eAQEA,iBACEA,iBACFA,QACAA,kBACEA,kBAA6CA,SAAsBA,QACnEA,kBAAgDA,SAAyBA,QAC3EA,QACFA,kCAZEA,0BAGAA,yCAGOA,uCAA2B,4BAGaA,wBACGA,4BCf9D,MAAMC,EAAiB,CAAC,CAAEC,KAAM,GAAIC,UCUpC,MAAM,QAGJC,YAAoBC,EAA8BC,GAA9BC,iBAA8BA,aAE3CC,WACLD,KAAKE,cACLF,KAAKG,iBAGCA,iBACN,MAAMC,GAAgBpB,QAAWgB,KAAKF,UAAW,eACjDE,KAAKK,aAAeC,EAAeF,GAG7BF,cACNF,KAAKD,MAAMQ,SAAS,+DAhBXC,GAAcf,kDAAde,EAAcC,8kBFd3BhB,iBACEA,iBACEA,iBACEA,iBAAqCA,wBAAYA,QACjDA,iBACEA,iBACEA,sCAgBFA,QACFA,QACFA,QACFA,QACFA,eAlBmCA,4sCEMtBe,GAAb,GDV+DpB,KAAM,CAAEsB,MAAO,WAMvE,IAAMC,EAAb,MAAM,sDAAOA,4DAHF,CAACC,cAAsBlB,IACtBkB,QAECD,GAAb,GEDaE,EAAb,MAAM,sDAAOA,4DAFF,CAACC,KAAcH,MAEbE,GAAb","names":["DEFAULT_OPTIONS","includeMetadataChanges","query","options","ref","Observable","subscriber","unsubscribe","onSnapshot","next","bind","error","complete","fromRef","pipe","map","changes","docs","collection","arr","snap","snapshot","data","exists","idField","id","snapToData","i0","routes","path","component","constructor","fireStore","title","this","ngOnInit","setMetaTags","getExperiences","expCollection","experiences$","collectionData","setTitle","WorksComponent","selectors","state","WorksRoutingModule","RouterModule","WorksModule","CommonModule"],"sources":["./node_modules/rxfire/firestore/index.esm.js","./src/app/works/works.component.html","./src/app/works/works.routing.ts","./src/app/works/works.component.ts","./src/app/works/works.module.ts"],"sourcesContent":["import { __spreadArray } from 'tslib';\nimport { onSnapshot, refEqual } from 'firebase/firestore';\nimport { Observable, pipe } from 'rxjs';\nimport { map, startWith, pairwise, filter, scan, distinctUntilChanged } from 'rxjs/operators';\n\n/**\n * @license\n * Copyright 2018 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar DEFAULT_OPTIONS = { includeMetadataChanges: false };\nfunction fromRef(ref, options) {\n    if (options === void 0) { options = DEFAULT_OPTIONS; }\n    /* eslint-enable @typescript-eslint/no-explicit-any */\n    return new Observable(function (subscriber) {\n        var unsubscribe = onSnapshot(ref, options, {\n            next: subscriber.next.bind(subscriber),\n            error: subscriber.error.bind(subscriber),\n            complete: subscriber.complete.bind(subscriber),\n        });\n        return { unsubscribe: unsubscribe };\n    });\n}\n\n/**\n * @license\n * Copyright 2018 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nfunction doc(ref) {\n    return fromRef(ref, { includeMetadataChanges: true });\n}\n/**\n * Returns a stream of a document, mapped to its data payload and optionally the document ID\n * @param query\n */\nfunction docData(ref, options) {\n    if (options === void 0) { options = {}; }\n    return doc(ref).pipe(map(function (snap) { return snapToData(snap, options); }));\n}\nfunction snapToData(snapshot, options) {\n    if (options === void 0) { options = {}; }\n    // TODO clean up the typings\n    var data = snapshot.data();\n    // match the behavior of the JS SDK when the snapshot doesn't exist\n    // it's possible with data converters too that the user didn't return an object\n    if (!snapshot.exists() || typeof data !== 'object' || data === null) {\n        return data;\n    }\n    if (options.idField) {\n        data[options.idField] = snapshot.id;\n    }\n    return data;\n}\n\n/**\n * @license\n * Copyright 2018 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar ALL_EVENTS = ['added', 'modified', 'removed'];\n/**\n * Create an operator that determines if a the stream of document changes\n * are specified by the event filter. If the document change type is not\n * in specified events array, it will not be emitted.\n */\nvar filterEvents = function (events) {\n    return filter(function (changes) {\n        var hasChange = false;\n        for (var i = 0; i < changes.length; i++) {\n            var change = changes[i];\n            if (events && events.indexOf(change.type) >= 0) {\n                hasChange = true;\n                break;\n            }\n        }\n        return hasChange;\n    });\n};\n/**\n * Splice arguments on top of a sliced array, to break top-level ===\n * this is useful for change-detection\n */\nfunction sliceAndSplice(original, start, deleteCount) {\n    var args = [];\n    for (var _i = 3; _i < arguments.length; _i++) {\n        args[_i - 3] = arguments[_i];\n    }\n    var returnArray = original.slice();\n    returnArray.splice.apply(returnArray, __spreadArray([start, deleteCount], args));\n    return returnArray;\n}\n/**\n * Creates a new sorted array from a new change.\n * @param combined\n * @param change\n */\nfunction processIndividualChange(combined, change) {\n    switch (change.type) {\n        case 'added':\n            if (combined[change.newIndex] &&\n                refEqual(combined[change.newIndex].doc.ref, change.doc.ref)) ;\n            else {\n                return sliceAndSplice(combined, change.newIndex, 0, change);\n            }\n            break;\n        case 'modified':\n            if (combined[change.oldIndex] == null ||\n                refEqual(combined[change.oldIndex].doc.ref, change.doc.ref)) {\n                // When an item changes position we first remove it\n                // and then add it's new position\n                if (change.oldIndex !== change.newIndex) {\n                    var copiedArray = combined.slice();\n                    copiedArray.splice(change.oldIndex, 1);\n                    copiedArray.splice(change.newIndex, 0, change);\n                    return copiedArray;\n                }\n                else {\n                    return sliceAndSplice(combined, change.newIndex, 1, change);\n                }\n            }\n            break;\n        case 'removed':\n            if (combined[change.oldIndex] &&\n                refEqual(combined[change.oldIndex].doc.ref, change.doc.ref)) {\n                return sliceAndSplice(combined, change.oldIndex, 1);\n            }\n            break;\n    }\n    return combined;\n}\n/**\n * Combines the total result set from the current set of changes from an incoming set\n * of changes.\n * @param current\n * @param changes\n * @param events\n */\nfunction processDocumentChanges(current, changes, events) {\n    if (events === void 0) { events = ALL_EVENTS; }\n    changes.forEach(function (change) {\n        // skip unwanted change types\n        if (events.indexOf(change.type) > -1) {\n            current = processIndividualChange(current, change);\n        }\n    });\n    return current;\n}\n/**\n * Create an operator that allows you to compare the current emission with\n * the prior, even on first emission (where prior is undefined).\n */\nvar windowwise = function () {\n    return pipe(startWith(undefined), pairwise());\n};\n/**\n * Given two snapshots does their metadata match?\n * @param a\n * @param b\n */\nvar metaDataEquals = function (a, b) { return JSON.stringify(a.metadata) === JSON.stringify(b.metadata); };\n/**\n * Create an operator that filters out empty changes. We provide the\n * ability to filter on events, which means all changes can be filtered out.\n * This creates an empty array and would be incorrect to emit.\n */\nvar filterEmptyUnlessFirst = function () {\n    return pipe(windowwise(), filter(function (_a) {\n        var prior = _a[0], current = _a[1];\n        return current.length > 0 || prior === undefined;\n    }), map(function (_a) {\n        _a[0]; var current = _a[1];\n        return current;\n    }));\n};\n/**\n * Return a stream of document changes on a query. These results are not in sort order but in\n * order of occurence.\n * @param query\n */\nfunction collectionChanges(query, options) {\n    if (options === void 0) { options = {}; }\n    return fromRef(query, { includeMetadataChanges: true }).pipe(windowwise(), map(function (_a) {\n        var priorSnapshot = _a[0], currentSnapshot = _a[1];\n        var docChanges = currentSnapshot.docChanges();\n        if (priorSnapshot && !metaDataEquals(priorSnapshot, currentSnapshot)) {\n            // the metadata has changed, docChanges() doesn't return metadata events, so let's\n            // do it ourselves by scanning over all the docs and seeing if the metadata has changed\n            // since either this docChanges() emission or the prior snapshot\n            currentSnapshot.docs.forEach(function (currentDocSnapshot, currentIndex) {\n                var currentDocChange = docChanges.find(function (c) {\n                    return refEqual(c.doc.ref, currentDocSnapshot.ref);\n                });\n                if (currentDocChange) {\n                    // if the doc is in the current changes and the metadata hasn't changed this doc\n                    if (metaDataEquals(currentDocChange.doc, currentDocSnapshot)) {\n                        return;\n                    }\n                }\n                else {\n                    // if there is a prior doc and the metadata hasn't changed skip this doc\n                    var priorDocSnapshot = priorSnapshot === null || priorSnapshot === void 0 ? void 0 : priorSnapshot.docs.find(function (d) {\n                        return refEqual(d.ref, currentDocSnapshot.ref);\n                    });\n                    if (priorDocSnapshot &&\n                        metaDataEquals(priorDocSnapshot, currentDocSnapshot)) {\n                        return;\n                    }\n                }\n                docChanges.push({\n                    oldIndex: currentIndex,\n                    newIndex: currentIndex,\n                    type: 'modified',\n                    doc: currentDocSnapshot\n                });\n            });\n        }\n        return docChanges;\n    }), filterEvents(options.events || ALL_EVENTS), filterEmptyUnlessFirst());\n}\n/**\n * Return a stream of document snapshots on a query. These results are in sort order.\n * @param query\n */\nfunction collection(query) {\n    return fromRef(query, { includeMetadataChanges: true }).pipe(map(function (changes) { return changes.docs; }));\n}\n/**\n * Return a stream of document changes on a query. These results are in sort order.\n * @param query\n */\nfunction sortedChanges(query, options) {\n    if (options === void 0) { options = {}; }\n    return collectionChanges(query, options).pipe(scan(function (current, changes) {\n        return processDocumentChanges(current, changes, options.events);\n    }, []), distinctUntilChanged());\n}\n/**\n * Create a stream of changes as they occur it time. This method is similar\n * to docChanges() but it collects each event in an array over time.\n */\nfunction auditTrail(query, options) {\n    if (options === void 0) { options = {}; }\n    return collectionChanges(query, options).pipe(scan(function (current, action) { return __spreadArray(__spreadArray([], current), action); }, []));\n}\n/**\n * Returns a stream of documents mapped to their data payload, and optionally the document ID\n * @param query\n */\nfunction collectionData(query, options) {\n    if (options === void 0) { options = {}; }\n    return collection(query).pipe(map(function (arr) {\n        return arr.map(function (snap) { return snapToData(snap, options); });\n    }));\n}\n\nexport { auditTrail, collection, collectionChanges, collectionData, doc, docData, fromRef, snapToData, sortedChanges };\n","<div class=\"page-wrapper\" id=\"works\">\r\n  <div class=\"vg-card\">\r\n    <div class=\"vg-card__content\">\r\n      <div class=\"vg-card__content__title\">Recent Works</div>\r\n      <div class=\"vg-card__content__text\">\r\n        <div class=\"recent-works\">\r\n          <a\r\n            class=\"recent-work border-line-h border-line-v\"\r\n            *ngFor=\"let experience of experiences$ | async\"\r\n            [href]=\"experience.url\"\r\n            target=\"_blank\"\r\n            rel=\"noreferrer\"\r\n            [attr.aria-label]=\"experience?.title\"\r\n          >\r\n            <div class=\"recent-work__cover\">\r\n              <img [src]=\"experience.imageUrl\" [alt]=\"experience?.title\" />\r\n            </div>\r\n            <div class=\"recent-work__description\">\r\n              <div class=\"recent-work__description__title\">{{ experience.title }}</div>\r\n              <div class=\"recent-work__description__category\">{{ experience.category }}</div>\r\n            </div>\r\n          </a>\r\n        </div>\r\n      </div>\r\n    </div>\r\n  </div>\r\n</div>\r\n","import { NgModule } from '@angular/core';\r\nimport { Routes, RouterModule } from '@angular/router';\r\nimport { WorksComponent } from './works.component';\r\n\r\nconst routes: Routes = [{ path: '', component: WorksComponent, data: { state: 'works' } }];\r\n\r\n@NgModule({\r\n  imports: [RouterModule.forChild(routes)],\r\n  exports: [RouterModule],\r\n})\r\nexport class WorksRoutingModule {}\r\n","import { ChangeDetectionStrategy, Component, OnInit } from '@angular/core';\r\nimport { Firestore } from '@angular/fire/firestore';\r\nimport { Title } from '@angular/platform-browser';\r\nimport { collection } from '@firebase/firestore';\r\nimport { collectionData } from 'rxfire/firestore';\r\nimport { Observable } from 'rxjs';\r\nimport { Experience } from './models/experience.model';\r\n\r\n@Component({\r\n  selector: 'vg-works',\r\n  templateUrl: './works.component.html',\r\n  styleUrls: ['./works.component.scss'],\r\n  changeDetection: ChangeDetectionStrategy.OnPush,\r\n})\r\nexport class WorksComponent implements OnInit {\r\n  public experiences$!: Observable<Experience[]>;\r\n\r\n  constructor(private fireStore: Firestore, private title: Title) {}\r\n\r\n  public ngOnInit(): void {\r\n    this.setMetaTags();\r\n    this.getExperiences();\r\n  }\r\n\r\n  private getExperiences(): void {\r\n    const expCollection = collection(this.fireStore, 'experiences');\r\n    this.experiences$ = collectionData(expCollection) as Observable<Experience[]>;\r\n  }\r\n\r\n  private setMetaTags(): void {\r\n    this.title.setTitle(`Vugar's Works`);\r\n  }\r\n}\r\n","import { NgModule } from '@angular/core';\r\nimport { CommonModule } from '@angular/common';\r\nimport { WorksComponent } from './works.component';\r\nimport { WorksRoutingModule } from './works.routing';\r\n\r\n@NgModule({\r\n  declarations: [WorksComponent],\r\n  imports: [CommonModule, WorksRoutingModule],\r\n})\r\nexport class WorksModule {}\r\n"],"sourceRoot":"webpack:///","file":"972.f6ee2b1d1889b6df9ac6.js"}